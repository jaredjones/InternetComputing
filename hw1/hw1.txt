Files you check in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Each of you are expected to put in your reasonable share of effort into it.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat. Your last check in before the deadline will be graded. So, if you break the code (in assignments) before the deadline, you will lose.

Please feel free to ask for frequent reviews (see the reviews/readme.txt file for details on how to ask for reviews).

You can evolve the answers and solutions based on the reviews to your pair and to other pairs in the course. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

Now to homework #1.

===============================================================================
Homework 1: Due July 13th, 11:59PM

To answer this question, read, but express the ideas in your own words. If something that you read is very expressive and you like to use it, you can use the exact words, but place the words within quotes and provide reference. Copying and pasting sentences or paragraphs from other sources is considered plagiarism, so don't copy and paste (or type exact words without proper reference).

1. What's hoisting in JavaScript?

JavaScript allows for the ability to create and use variables before they have been declared, this is done through hoisting. This means you can instantiate a variable, let's say ‘x = 5’ at the top of your program, but then you can declare x as ‘var x’ at the very bottom of your program and you will still get a functioning program. This happens due to the JavaScript preprocessor running before code is executed in the interpreter. The JSC will first run through your code and grab out all variables and assigned function names before it actually creates any memory for the program to run in. 

However, hoisting also has major benefits when you are returning a function pointer and that function uses a variable that was declared as an argument from the calling function. This variable is pushed onto the stack and is hoisted whenever the function is called; however, after the full function call has ended the memory falls off the stack. Hoisting in a nested function is useful because in the case of returning a function pointer, it allows an argument to be passed into a function that is held in stack memory that can be used when that nested function is executed. This is particularly useful when using predicates, and you need to pass a parameter into the predicate definition. 

2. What's the difference between calling a function directly and calling it with call or apply?

Calling a function using either 'call' or 'apply' allows you to replace the object’s context of the called function. This works by passing into the first argument of either call/apply as a context of a function you are calling. From this point the function is then able to reference its changed context object by using the "this" operator. While 'call' and 'apply' are both very similar, they differ in one simple area. The 2nd parameter passed contains either a list of arguments separated by a comma or an array of arguments passed to the function. Call takes in the former while apply takes in the latter; call takes in a list of elements, and apply takes in an array of elements. Changing the context of a function can be particularly useful when the function needs to modify or make changes on an object.

3. When would you use call vs. apply?

Use either call or apply when you want to change the context of a function. Call should be used when you have a list of arguments separated by a comma that you want to pass into a function. On the other hand, a programmer should use ‘apply’ whenever they have an array of arguments that they are passing to a function. Both ‘call’ and ‘apply’ change the context of the function by setting ‘this’ to the first argument passed into call/apply.

